<!doctype html>
<html lang="et">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>sukram.page</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #050509;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    /* väike “pehme kuma” */
    .vignette {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(900px 600px at 50% 40%, rgba(255, 60, 180, 0.10), transparent 65%),
        radial-gradient(1200px 900px at 50% 55%, rgba(255, 60, 180, 0.06), transparent 70%),
        radial-gradient(1200px 900px at 50% 50%, rgba(0,0,0,0.0), rgba(0,0,0,0.55));
      mix-blend-mode: screen;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="vignette"></div>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize() {
      canvas.width = Math.floor(innerWidth * DPR);
      canvas.height = Math.floor(innerHeight * DPR);
    }
    addEventListener("resize", resize);
    resize();

    // --- Heart math (parametric) ---
    // Classic heart curve:
    // x = 16 sin^3(t)
    // y = 13 cos(t) - 5 cos(2t) - 2 cos(3t) - cos(4t)
    function heartPoint(t) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      return { x, y };
    }

    // Generate target points along heart outline
    function buildTargets(count) {
      const pts = [];
      for (let i = 0; i < count; i++) {
        const t = (i / count) * Math.PI * 2;
        const p = heartPoint(t);

        // Outline thickness: push points slightly inward/outward randomly
        const n = (Math.random() * 0.9 - 0.45);
        const nx = p.x * (1 + n * 0.03);
        const ny = p.y * (1 + n * 0.03);

        pts.push({ x: nx, y: ny, t });
      }
      return pts;
    }

    const targets = buildTargets(420);

    // --- Particles ---
    const particles = [];
    const MAX = 900;

    function rand(a,b){ return a + Math.random()*(b-a); }

    function worldToScreen(wx, wy) {
      // scale heart to screen
      const w = canvas.width, h = canvas.height;
      const s = Math.min(w, h) * 0.020; // adjust heart size
      const cx = w * 0.5;
      const cy = h * 0.48;
      return { x: cx + wx * s, y: cy - wy * s };
    }

    function spawn() {
      const pick = targets[(Math.random() * targets.length) | 0];
      const p = heartPoint(pick.t);

      // spawn near its target with some jitter
      const jitter = 0.8;
      const wx = p.x + rand(-jitter, jitter);
      const wy = p.y + rand(-jitter, jitter);

      const { x, y } = worldToScreen(wx, wy);

      // small floating hearts
      particles.push({
        x: x + rand(-10, 10) * DPR,
        y: y + rand(-10, 10) * DPR,
        tx: x,
        ty: y,
        vx: rand(-0.35, 0.35) * DPR,
        vy: rand(-0.35, 0.35) * DPR,
        a: rand(0.55, 1.0),
        size: rand(6, 14) * DPR,
        rot: rand(-0.6, 0.6),
        vr: rand(-0.02, 0.02),
        life: rand(120, 260),
        hue: rand(320, 345),     // pink range
        sat: rand(70, 95),
        lum: rand(55, 70),
      });
      if (particles.length > MAX) particles.splice(0, particles.length - MAX);
    }

    // Draw a tiny heart icon
    function drawMiniHeart(x, y, s, rot, color, glow) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot);

      ctx.shadowColor = glow;
      ctx.shadowBlur = 16 * DPR;

      ctx.fillStyle = color;
      ctx.beginPath();
      // simple heart path (normalized)
      ctx.moveTo(0, -0.35*s);
      ctx.bezierCurveTo(0.55*s, -0.95*s, 1.35*s, -0.15*s, 0, 0.95*s);
      ctx.bezierCurveTo(-1.35*s, -0.15*s, -0.55*s, -0.95*s, 0, -0.35*s);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    let tick = 0;

    function step() {
      tick++;

      // background fade for trailing glow
      ctx.fillStyle = "rgba(5, 5, 9, 0.24)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // keep spawning
      for (let i = 0; i < 10; i++) spawn();

      // subtle “pulse” for heart movement
      const pulse = 1 + Math.sin(tick * 0.04) * 0.015;

      // update & draw particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

        // pull toward target
        const dx = (p.tx - p.x);
        const dy = (p.ty - p.y);

        p.vx += dx * 0.0009;
        p.vy += dy * 0.0009;

        // slight upward drift + noise
        p.vy += (-0.010 * DPR);
        p.vx += Math.sin((tick + i) * 0.02) * 0.003 * DPR;

        p.x += p.vx * pulse;
        p.y += p.vy * pulse;

        p.rot += p.vr;

        // fade out
        p.life -= 1;
        p.a *= 0.995;

        const alpha = Math.max(0, Math.min(1, p.a));
        const color = `hsla(${p.hue}, ${p.sat}%, ${p.lum}%, ${alpha})`;
        const glow = `hsla(${p.hue}, 100%, 65%, ${alpha})`;

        // sparkle: occasional bright pop
        let size = p.size;
        if (Math.random() < 0.015) size *= 1.35;

        drawMiniHeart(p.x, p.y, size, p.rot, color, glow);

        // remove dead
        if (p.life <= 0 || alpha < 0.02) particles.splice(i, 1);
      }

      // extra soft center glow
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      const w = canvas.width, h = canvas.height;
      const grad = ctx.createRadialGradient(w*0.5, h*0.48, 10*DPR, w*0.5, h*0.48, Math.min(w,h)*0.35);
      grad.addColorStop(0, "rgba(255, 60, 180, 0.08)");
      grad.addColorStop(1, "rgba(255, 60, 180, 0.0)");
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,w,h);
      ctx.restore();

      requestAnimationFrame(step);
    }

    // start with solid background once
    ctx.fillStyle = "#050509";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    step();
  </script>
</body>
</html>
